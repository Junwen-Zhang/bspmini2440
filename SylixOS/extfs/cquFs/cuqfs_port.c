/*********************************************************************************************************
**
**                                    中国软件开源组织
**
**                                   嵌入式实时操作系统
**
**                                     SylixOS(TM)
**
**                               Copyright All Rights Reserved
**
**--------------文件信息--------------------------------------------------------------------------------
**
** 文   件   名: cqufs_port.h
**
** 创   建   人: cqu Group
**
** 文件创建日期: 2022 年 06 月 04 日
**
** 描        述: cqufs向上接口文件
*********************************************************************************************************/
#define  __SYLIXOS_STDIO
#define  __SYLIXOS_KERNEL //加了这两句可以使用已定义的内核函数和结构
#include "cqufs.h"
#include "cqufs_port.h"
#include "../../driver/mtd/nor/nor.h"
#include "SylixOS.h"

#ifndef LITTLEFS_DISABLE



/* 为了匹配SylixOS，对SuperBlock又做了一层封装，加入了文件共享信息 */
typedef struct cqufs_volume{
    LW_DEV_HDR          CQUFS_devhdrHdr;                                /*  cqufs 文件系统设备头        */
    LW_OBJECT_HANDLE    CQUFS_hVolLock;                                 /*  卷操作锁                    */
    LW_LIST_LINE_HEADER CQUFS_plineFdNodeHeader;                        /*  fd_node 链表                */
    LW_LIST_LINE_HEADER CQUFS_plineSon;                                 /*  儿子链表                    */

    BOOL                CQUFS_bForceDelete;                             /*  是否允许强制卸载卷          */
    BOOL                CQUFS_bValid;

    uid_t               CQUFS_uid;                                      /*  用户 id                     */
    gid_t               CQUFS_gid;                                      /*  组   id                     */
    mode_t              CQUFS_mode; //new xmy
    time_t              CQUFS_time;                                     /*  创建时间                    */

    //new xmy
    ULONG               CQUFS_ulCurBlk;
    ULONG               CQUFS_ulMaxBlk;

    cqufs_t* cqufst;
    // struct cqufs_config* mycfg;
    //const struct cqufs_config cfg;
} CQUFS_VOLUME;
typedef CQUFS_VOLUME*     PCQUFS_VOLUME;

/* 为了匹配SylixOS，将dir和file类型封装为node文件节点，并加入了文件共享信息 */
typedef struct cqufs_node {
    PCQUFS_VOLUME         CQUFSN_pcqufs;                                    /*  文件系统                    */

    BOOL                CQUFSN_bChanged;                                  /*  文件内容是否更改            */
    mode_t              CQUFSN_mode;                                      /*  文件 mode                   */
    time_t              CQUFSN_timeCreate;                                /*  创建时间                    */
    time_t              CQUFSN_timeAccess;                                /*  最后访问时间                */
    time_t              CQUFSN_timeChange;                                /*  最后修改时间                */

    size_t              CQUFSN_stSize;                                    /*  当前文件大小 (可能大于缓冲) */
    size_t              CQUFSN_stVSize;                                   /*  lseek 出的虚拟大小          */

    uid_t               CQUFSN_uid;                                       /*  用户 id                     */
    gid_t               CQUFSN_gid;                                       /*  组   id                     */
    PCHAR               CQUFSN_pcName;                                    /*  文件名称                    */
    PCHAR               CQUFSN_pcLink;                                    /*  链接目标                    */

    /* 有两种类型，根据isfile判断，其中一个指针为空 */
    bool isfile;
    cqufs_dir_t* cqufsdir;
    cqufs_file_t* cqufsfile;
} CQUFS_NODE;
typedef CQUFS_NODE*       PCQUFS_NODE;

#define __CQUFS_FILE_LOCK(pcqufsn)        API_SemaphoreMPend(pcqufsn->CQUFSN_pcqufs->CQUFS_hVolLock, \
                                      LW_OPTION_WAIT_INFINITE)
#define __CQUFS_FILE_UNLOCK(pcqufsn)      API_SemaphoreMPost(pcqufsn->CQUFSN_pcqufs->CQUFS_hVolLock)

#define __CQUFS_VOL_LOCK(pfs)           API_SemaphoreMPend(pfs->CQUFS_hVolLock, \
                                      LW_OPTION_WAIT_INFINITE)
#define __CQUFS_VOL_UNLOCK(pfs)         API_SemaphoreMPost(pfs->CQUFS_hVolLock)

#define __STR_IS_ROOT(pcName)         ((pcName[0] == PX_EOS) || (lib_strcmp(PX_STR_ROOT, pcName) == 0))


/***********************************************************************************************************
*                                         定义一些内部常量                                                 *
***********************************************************************************************************/
const static INT READ_SIZE_AM29LV160DB        = 16;
const static INT PROG_SIZE_AM29LV160DB        = 16;
const static INT BLOCK_SIZE_AM29LV160DB       = 64 * 1024;
const static INT BLOCK_COUNT_AM29LV160DB      = 32;
const static INT CACHE_SIZE_AM29LV160DB       = 1024;
const static INT LOOKAHEAD_SIZE_AM29LV160DB   = 16;
const static INT BLOCK_CYCLES_AM29LV160DB     = 500;

static INT _G_iLittleFsDrvNum           = PX_ERROR;

/***********************************************************************************************************
*                                         一些内部函数                                                     *
***********************************************************************************************************/

/* 定义基本读写擦操作与NorFlash驱动的接口,都是内联函数 */

/**
 * cqufs与底层flash读数据接口
 * @pacqufs  c
 * @pacqufs  block  块编号
 * @pacqufs  off    块内偏移地址
 * @pacqufs  buffer 用于存储读取到的数据
 * @pacqufs  size   要读取的字节数
 * @return
 */
static int cqufs_mini2440_read(const struct cqufs_config *c, cqufs_block_t block, cqufs_off_t off, void *buffer, cqufs_size_t size)
{
    //xmy
    // write_nor(c->block_size * block + off, buffer, size, WRITE_KEEP);
    // read_nor(off,buffer,size);
    printf("cqufs_mini2440_read--------------\n");
    int a = read_nor(c->block_size * block + off, buffer, size);
    printf("%d---------------\n",a);
    //printf("%s -------------------------------\n",buffer);
    return CQUFS_ERR_OK;
}

/**
 * cqufs与底层flash写数据接口
 * @pacqufs  c
 * @pacqufs  block  块编号
 * @pacqufs  off    块内偏移地址
 * @pacqufs  buffer 待写入的数据
 * @pacqufs  size   待写入数据的大小
 * @return
 */
static int cqufs_mini2440_prog(const struct cqufs_config *c, cqufs_block_t block, cqufs_off_t off, const void *buffer, cqufs_size_t size)
{
    // read_nor(c->block_size * block + off, buffer, size);
    printf("cqufs_mini2440_write--------------\n");
    write_nor(c->block_size * block + off, buffer, size, WRITE_KEEP);
    return CQUFS_ERR_OK;
}

/**
 * cqufs与底层flash擦除接口
 * @pacqufs  c
 * @pacqufs  block 块编号
 * @return
 */
static int cqufs_mini2440_erase(const struct cqufs_config *c, cqufs_block_t block)
{
    printf("cqufs_mini2440_erase--------------\n");
    erase_nor(c->block_size * block, ERASE_SECTOR);
    return CQUFS_ERR_OK;
}

static int cqufs_mini2440_sync(const struct cqufs_config *c)
{
    printf("cqufs_mini2440_sync--------------\n");
    return CQUFS_ERR_OK;
}

// static inline void littleConfigInitialize(struct cqufs_config* cfg){
//     printf("littleConfigInitialize 1-----------------\n");
//     // 静态内存使用方式必须设定这四个缓存
//     __align(4) static uint8_t read_buffer[16];
//     __align(4) static uint8_t prog_buffer[16];
//     __align(4) static uint8_t lookahead_buffer[16];

//     printf("littleConfigInitialize 2-----------------\n");
//     // block device operations
//     //cfg->read = NULL;
//     printf("littleConfigInitialize 2 read -----------------------\n");
//     cfg->read  = cqufs_mini2440_read;
//     printf("littleConfigInitialize 2 read finish-----------------\n");
//     cfg->prog  = cqufs_mini2440_prog;
//     cfg->erase = cqufs_mini2440_erase;
//     cfg->sync  = cqufs_mini2440_sync;

//     printf("littleConfigInitialize 3-----------------\n");
//     // block device configuration
    // cfg->read_size = READ_SIZE_AM29LV160DB;
    // cfg->prog_size = PROG_SIZE_AM29LV160DB;
    // cfg->block_size = BLOCK_SIZE_AM29LV160DB;
    // cfg->block_count = BLOCK_COUNT_AM29LV160DB;
    // cfg->cache_size = CACHE_SIZE_AM29LV160DB;
    // cfg->lookahead_size = LOOKAHEAD_SIZE_AM29LV160DB;
    // cfg->block_cycles = BLOCK_CYCLES_AM29LV160DB;
    
//     printf("littleConfigInitialize 4-----------------\n");
//     // 使用静态内存必须设置这几个缓存
//     cfg->read_buffer = read_buffer;
//     cfg->prog_buffer = prog_buffer;
//     cfg->lookahead_buffer = lookahead_buffer;
// }

//xmy
// cqufs句柄
cqufs_t cqufs_test;
// cqufs_file_t cqufs_file_w25qxx;
__align(4) static uint8_t read_buffer[16];
__align(4) static uint8_t prog_buffer[16];
__align(4) static uint8_t lookahead_buffer[16];
const struct cqufs_config cfg =
{
	// block device operations
	.read  = cqufs_mini2440_read,
	.prog  = cqufs_mini2440_prog,
	.erase = cqufs_mini2440_erase,
	.sync  = cqufs_mini2440_sync,

	// block device configuration
	.read_size = 16,
	.prog_size = 16,
	.block_size = 64 * 1024,
	.block_count = 32,
	.cache_size = 1024,
	.lookahead_size = 16,
	.block_cycles = 500,

	//
	// 使用静态内存必须设置这几个缓存
	//
	.read_buffer = read_buffer,
	.prog_buffer = prog_buffer,
	.lookahead_buffer = lookahead_buffer,
};


/*********************************************************************************************************
** 函数名称: __little_stat
** 功能描述: cqufs 获得文件 stat
** 输　入  : pcqufsn            文件节点
**           pcqufs           文件系统
**           pstat            获得的 stat
** 输　出  : 创建结果
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static inline void __cqufs_stat (PCQUFS_NODE  pcqufsn, PCQUFS_VOLUME  pcqufs, struct stat  *pstat)
{
    if (pcqufsn) {
        pstat->st_dev     = LW_DEV_MAKE_STDEV(&pcqufs->CQUFS_devhdrHdr);
        pstat->st_ino     = (ino_t)pcqufsn;
        pstat->st_mode    = pcqufsn->CQUFSN_mode;
        pstat->st_nlink   = 1;
        pstat->st_uid     = pcqufsn->CQUFSN_uid;
        pstat->st_gid     = pcqufsn->CQUFSN_gid;
        pstat->st_rdev    = 1;
        pstat->st_size    = (off_t)pcqufsn->CQUFSN_stSize;
        pstat->st_atime   = pcqufsn->CQUFSN_timeAccess;
        pstat->st_mtime   = pcqufsn->CQUFSN_timeChange;
        pstat->st_ctime   = pcqufsn->CQUFSN_timeCreate;
    
    } else {
        pstat->st_dev     = LW_DEV_MAKE_STDEV(&pcqufs->CQUFS_devhdrHdr);
        pstat->st_ino     = (ino_t)0;
        pstat->st_nlink   = 1;
        pstat->st_uid     = pcqufs->CQUFS_uid;
        pstat->st_gid     = pcqufs->CQUFS_gid;
        pstat->st_rdev    = 1;
        pstat->st_size    = 0;
        pstat->st_atime   = pcqufs->CQUFS_time;
        pstat->st_mtime   = pcqufs->CQUFS_time;
        pstat->st_ctime   = pcqufs->CQUFS_time;
        pstat->st_blocks  = 0;
    }  
    pstat->st_resv1 = LW_NULL;
    pstat->st_resv2 = LW_NULL;
    pstat->st_resv3 = LW_NULL;
}

/*********************************************************************************************************
** 函数名称: __little_statfs
** 功能描述: cqufs 获得文件 stat
** 输　入  : pfs           文件系统
**           pstatfs          获得的 statfs
** 输　出  : 创建结果
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static inline void  __cqufs_statfs (PCQUFS_VOLUME  pfs, struct statfs  *pstatfs)
{
    pstatfs->f_type   = TMPFS_MAGIC;
    pstatfs->f_bavail = 1;
    
    pstatfs->f_files  = 0;
    pstatfs->f_ffree  = 0;
    
#if LW_CFG_CPU_WORD_LENGHT == 64
    pstatfs->f_fsid.val[0] = (int32_t)((addr_t)pfs >> 32);
    pstatfs->f_fsid.val[1] = (int32_t)((addr_t)pfs & 0xffffffff);
#else
    pstatfs->f_fsid.val[0] = (int32_t)pfs;
    pstatfs->f_fsid.val[1] = 0;
#endif
    
    pstatfs->f_flag    = 0;
    pstatfs->f_namelen = PATH_MAX;
}


/*********************************************************************************************************
** 函数名称: __littleOpen
** 功能描述: 打开或者创建文件
** 输　入  : pfs              内存中HoitFs文件系统的super block
**           pcName           文件名
**           iFlags           方式
**           iMode            mode_t
** 输　出  : < 0 错误
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static LONG __littleFsOpen(PCQUFS_VOLUME     pfs,
    PCHAR           pcName,
    INT             iFlags,
    INT             iMode)
{
    PLW_FD_NODE         pfdnode;
    cqufs_file_t* pcqufsfile;
    cqufs_dir_t* pcqufsdir;
    PCQUFS_NODE pcqufsn;
    struct stat statGet;
    BOOL        bIsNew;
//    BOOL        bCreate = LW_FALSE;

    if (pcName == LW_NULL) {
        _ErrorHandle(EFAULT);                                           /*  Bad address                 */
        return  (PX_ERROR);
    }

    if (iFlags & O_CREAT) {                                             /*  创建操作                    */
        if (__fsCheckFileName(pcName)) {
            _ErrorHandle(ENOENT);
            return  (PX_ERROR);
        }
        if (S_ISFIFO(iMode) ||
            S_ISBLK(iMode) ||
            S_ISCHR(iMode) ||
            S_ISLNK(iMode)) {
            _ErrorHandle(ERROR_IO_DISK_NOT_PRESENT);                    /*  不支持以上这些格式          */
            return  (PX_ERROR);
        }
    }

    if (__CQUFS_VOL_LOCK(pfs) != ERROR_NONE) {
        _ErrorHandle(ENXIO);                                            /*  设备出错                    */
        return  (PX_ERROR);
    }

    /************************************ TODO ************************************/
    
    
    if(S_ISDIR(iMode)){
        cqufs_dir_open(pfs->cqufst,pcqufsdir,pcName);
        pcqufsn->isfile=false;
        pcqufsn->cqufsdir=pcqufsdir;
    }
    else{
        if(S_ISREG(iMode))cqufs_file_open(pfs->cqufst,pcqufsfile,pcName,iFlags);
        pcqufsn->isfile=true;
        pcqufsn->cqufsfile=pcqufsfile;
    }

    if (pcqufsfile||pcqufsdir) {
        if (!S_ISLNK(pcqufsn->CQUFSN_mode)) {
            if ((iFlags & O_CREAT) && (iFlags & O_EXCL)) {              /*  排他创建文件                */
                __CQUFS_VOL_UNLOCK(pfs);
                _ErrorHandle(EEXIST);                                   /*  已经存在文件                */
                return  (PX_ERROR);            
            } else if ((iFlags & O_DIRECTORY) && !S_ISDIR(pcqufsn->CQUFSN_mode)) {
                __CQUFS_VOL_UNLOCK(pfs);
                _ErrorHandle(ENOTDIR);
                return  (PX_ERROR);
            } 
        }
    } 

    __cqufs_stat(pcqufsn, pfs, &statGet);
    pfdnode = API_IosFdNodeAdd(&pfs->CQUFS_plineFdNodeHeader,
                               statGet.st_dev,
                               (ino64_t)statGet.st_ino,
                               iFlags,
                               iMode,
                               statGet.st_uid,
                               statGet.st_gid,
                               statGet.st_size,
                               (PVOID)pcqufsn,
                               &bIsNew);    

    pfdnode->FDNODE_pvFsExtern = (PVOID)pfs;                            /*  记录文件系统信息            */

    LW_DEV_INC_USE_COUNT(&pfs->CQUFS_devhdrHdr);                          /*  更新计数器                  */
    __CQUFS_VOL_UNLOCK(pfs);

    return  ((LONG)pfdnode);                                            /*  返回文件节点                */
}

/*********************************************************************************************************
** 函数名称: __littleFsRemove
** 功能描述: fs remove 操作
** 输　入  : pfs           卷设备
**           pcName           文件名
**           注意文件名如果为空就是卸载本文件系统
** 输　出  : < 0 表示错误
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsRemove (PCQUFS_VOLUME   pfs,
                           PCHAR         pcName)
{
//    PLW_FD_NODE         pfdnode;
    cqufs_file_t* pcqufsfile;
    cqufs_dir_t* pcqufsdir;
    PCQUFS_NODE pcqufsn;

    // BOOL       bRoot;
    // PCHAR      pcTail;
    // INT        iError;

    if (pcName == LW_NULL) {
        _ErrorHandle(ERROR_IO_NO_DEVICE_NAME_IN_PATH);
        return  (PX_ERROR);
    }
        
    if (__CQUFS_VOL_LOCK(pfs) != ERROR_NONE) {
        _ErrorHandle(ENXIO);                                            /*  设备出错                    */
        return  (PX_ERROR);
    }
    
    struct cqufs_info* cqufsinfo;
    int error=cqufs_stat(pfs->cqufst,pcName,cqufsinfo);
    if(!error){
        if(cqufsinfo->type==CQUFS_TYPE_DIR){
            cqufs_dir_open(pfs->cqufst,pcqufsdir,pcName);
            pcqufsn->isfile=false;
            pcqufsn->cqufsdir=pcqufsdir;
        }
        else{
            cqufs_file_open(pfs->cqufst,pcqufsfile,pcName,CQUFS_O_RDWR);
            pcqufsn->isfile=true;
            pcqufsn->cqufsfile=pcqufsfile;
        }
    }else{
        __CQUFS_VOL_UNLOCK(pfs);
        _ErrorHandle(ENOENT);
        return  (PX_ERROR);
    }
    
    if (pcqufsfile||pcqufsdir) {
        cqufs_remove(pfs->cqufst,pcName);
        __CQUFS_VOL_UNLOCK(pfs);
        return  (ERROR_NONE);
            
    } else if (!pcName) {                                                 /*  删除 cqufs 文件系统         */
        if (pfs->CQUFS_bValid == LW_FALSE) {
            __CQUFS_VOL_UNLOCK(pfs);
            return  (ERROR_NONE);                                       /*  正在被其他任务卸载          */
        }
        
__re_umount_vol:
    if (LW_DEV_GET_USE_COUNT((LW_DEV_HDR *)pfs)) {
        if (!pfs->CQUFS_bForceDelete) {
            __CQUFS_VOL_UNLOCK(pfs);
            _ErrorHandle(EBUSY);
            return  (PX_ERROR);
        }
        
        pfs->CQUFS_bValid = LW_FALSE;
        
        __CQUFS_VOL_UNLOCK(pfs);
        
        _DebugHandle(__ERRORMESSAGE_LEVEL, "LittleFS: disk have open file.\r\n");
        iosDevFileAbnormal(&pfs->CQUFS_devhdrHdr);               /*  将所有相关文件设为异常模式  */
        
        __CQUFS_VOL_LOCK(pfs);
        goto    __re_umount_vol;
    
    } else {
        pfs->CQUFS_bValid = LW_FALSE;
    }
        
        iosDevDelete((LW_DEV_HDR *)pfs);                             /*  IO 系统移除设备             */
        API_SemaphoreMDelete(&pfs->CQUFS_hVolLock);
        
        cqufs_unmount(pfs->cqufst);                                          /*  释放所有文件内容            */
        __SHEAP_FREE(pfs);
        
        _DebugHandle(__LOGMESSAGE_LEVEL, "LittleFS: Lfs unmount ok.\r\n");
        
        return  (ERROR_NONE);
        
    } else {
        __CQUFS_VOL_UNLOCK(pfs);
        _ErrorHandle(ENOENT);
        return  (PX_ERROR);
    }
}

/*********************************************************************************************************
** 函数名称: __littleFsClose
** 功能描述: fs close 操作
** 输　入  : pfdentry         文件控制块
** 输　出  : < 0 表示错误
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsClose (PLW_FD_ENTRY    pfdentry)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn   = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    PCQUFS_VOLUME   pfs  = (PCQUFS_VOLUME)pfdnode->FDNODE_pvFsExtern;
    BOOL          bRemove = LW_FALSE;
    
    if (__CQUFS_VOL_LOCK(pfs) != ERROR_NONE) {
        _ErrorHandle(ENXIO);                                            /*  设备出错                    */
        return  (PX_ERROR);
    }
    
    if (API_IosFdNodeDec(&pfs->CQUFS_plineFdNodeHeader, 
                         pfdnode, &bRemove) == 0) {
        if (pcqufsn->cqufsdir) {
            cqufs_dir_close(pfs->cqufst, pcqufsn->cqufsdir);
        }else{
            cqufs_file_close(pfs->cqufst, pcqufsn->cqufsfile);
        }
    }
    
    LW_DEV_DEC_USE_COUNT(&pfs->CQUFS_devhdrHdr);
        
    __CQUFS_VOL_UNLOCK(pfs);

    return  (ERROR_NONE);
}

/*********************************************************************************************************
** 函数名称: __littleFsRead
** 功能描述: fs read 操作
** 输　入  : pfdentry         文件控制块
**           pcBuffer         接收缓冲区
**           stMaxBytes       接收缓冲区大小
** 输　出  : 驱动相关
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static ssize_t  __littleFsRead (PLW_FD_ENTRY pfdentry,
                             PCHAR        pcBuffer,
                             size_t       stMaxBytes)
{
    PLW_FD_NODE   pfdnode    = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn      = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    ssize_t       sstReadNum = PX_ERROR;
    
    if (!pcBuffer) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (pcqufsn == LW_NULL) {
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_FILE_LOCK(pcqufsn) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (S_ISDIR(pcqufsn->CQUFSN_mode)) {
        __CQUFS_FILE_UNLOCK(pcqufsn);
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (stMaxBytes) {
        if(pcqufsn->cqufsdir){
            _DebugHandle(__LOGMESSAGE_LEVEL, "LittleFS: you can not resd a directory.\r\n");
        }else{
            sstReadNum = cqufs_file_read(pcqufsn->CQUFSN_pcqufs, pcqufsn->cqufsfile, pcBuffer, stMaxBytes);
            if (sstReadNum > 0) {
                pfdentry->FDENTRY_oftPtr += (off_t)sstReadNum;              /*  更新文件指针                */
            }  
        }        
    } else {
        sstReadNum = 0;
    }
    
    __CQUFS_FILE_UNLOCK(pcqufsn);
    
    return  (sstReadNum);
}

/*********************************************************************************************************
** 函数名称: __littleFsPRead
** 功能描述: fs pread 操作
** 输　入  : pfdentry         文件控制块
**           pcBuffer         接收缓冲区
**           stMaxBytes       接收缓冲区大小
**           oftPos           位置
** 输　出  : 驱动相关
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static ssize_t  __littleFsPRead (PLW_FD_ENTRY pfdentry,
                              PCHAR        pcBuffer,
                              size_t       stMaxBytes,
                              off_t        oftPos)
{
    PLW_FD_NODE   pfdnode    = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn      = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    ssize_t       sstReadNum = PX_ERROR;
    
    if (!pcBuffer || (oftPos < 0)) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (pcqufsn == LW_NULL) {
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_FILE_LOCK(pcqufsn) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (S_ISDIR(pcqufsn->CQUFSN_mode)) {
        __CQUFS_FILE_UNLOCK(pcqufsn);
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (stMaxBytes) {
        if(pcqufsn->cqufsdir){
            _DebugHandle(__LOGMESSAGE_LEVEL, "LittleFS: you can not resd a directory.\r\n");
        }else{
            cqufs_file_seek(pcqufsn->CQUFSN_pcqufs, pcqufsn->cqufsfile,oftPos,CQUFS_SEEK_SET);
            sstReadNum = cqufs_file_read(pcqufsn->CQUFSN_pcqufs, pcqufsn->cqufsfile, pcBuffer, stMaxBytes);
            if (sstReadNum > 0) {
                pfdentry->FDENTRY_oftPtr += (off_t)sstReadNum;              /*  更新文件指针                */
            }  
        }
         
    } else {
        sstReadNum = 0;
    }
    
    __CQUFS_FILE_UNLOCK(pcqufsn);
    
    return  (sstReadNum);
}

/*********************************************************************************************************
** 函数名称: __littleFsWrite
** 功能描述: fs write 操作
** 输　入  : pfdentry         文件控制块
**           pcBuffer         缓冲区
**           stNBytes         需要写入的数据
** 输　出  : 驱动相关
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static ssize_t  __littleFsWrite (PLW_FD_ENTRY  pfdentry,
                              PCHAR         pcBuffer,
                              size_t        stNBytes)
{
    PLW_FD_NODE   pfdnode     = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn       = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    ssize_t       sstWriteNum = PX_ERROR;
    
    if (!pcBuffer) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (pcqufsn == LW_NULL) {
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_FILE_LOCK(pcqufsn) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (S_ISDIR(pcqufsn->CQUFSN_mode)) {
        __CQUFS_FILE_UNLOCK(pcqufsn);
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (pfdentry->FDENTRY_iFlag & O_APPEND) {                           /*  追加模式                    */
        pfdentry->FDENTRY_oftPtr = pfdnode->FDNODE_oftSize;             /*  移动读写指针到末尾          */
    }

    if (stNBytes) {
        if(pcqufsn->cqufsdir){
            _DebugHandle(__LOGMESSAGE_LEVEL, "LittleFS: you can not write a directory.\r\n");
        }else{
            sstWriteNum = cqufs_file_write(pcqufsn->CQUFSN_pcqufs, pcqufsn->cqufsfile, pcBuffer, stNBytes);
        }
        if (sstWriteNum > 0) {
                pfdentry->FDENTRY_oftPtr += (off_t)sstWriteNum;             /*  更新文件指针                */
                pfdnode->FDNODE_oftSize   = (off_t)pcqufsn->CQUFSN_stSize;
        }   
    } else {
        sstWriteNum = 0;
    }
    
    __CQUFS_FILE_UNLOCK(pcqufsn);
    
    return  (sstWriteNum);
}

/*********************************************************************************************************
** 函数名称: __littleFsPWrite
** 功能描述: fs pwrite 操作
** 输　入  : pfdentry         文件控制块
**           pcBuffer         缓冲区
**           stNBytes         需要写入的数据
**           oftPos           位置
** 输　出  : 驱动相关
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static ssize_t  __littleFsPWrite (PLW_FD_ENTRY  pfdentry,
                               PCHAR         pcBuffer,
                               size_t        stNBytes,
                               off_t         oftPos)
{
    PLW_FD_NODE   pfdnode     = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn       = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    ssize_t       sstWriteNum = PX_ERROR;
    
    if (!pcBuffer || (oftPos < 0)) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (pcqufsn == LW_NULL) {
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_FILE_LOCK(pcqufsn) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (S_ISDIR(pcqufsn->CQUFSN_mode)) {
        __CQUFS_FILE_UNLOCK(pcqufsn);
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (stNBytes) {
        if(pcqufsn->cqufsdir){
            _DebugHandle(__LOGMESSAGE_LEVEL, "LittleFS: you can not write a directory.\r\n");
        }else{
            cqufs_file_seek(pcqufsn->CQUFSN_pcqufs, pcqufsn->cqufsfile,oftPos,CQUFS_SEEK_SET);
            sstWriteNum = cqufs_file_write(pcqufsn->CQUFSN_pcqufs, pcqufsn->cqufsfile, pcBuffer, stNBytes);
        }
        if (sstWriteNum > 0) {
                pfdentry->FDENTRY_oftPtr += (off_t)sstWriteNum;             /*  更新文件指针                */
                pfdnode->FDNODE_oftSize   = (off_t)pcqufsn->CQUFSN_stSize;
        }   
    } else {
        sstWriteNum = 0;
    }
    
    __CQUFS_FILE_UNLOCK(pcqufsn);
    
    return  (sstWriteNum);
}

/*********************************************************************************************************
** 函数名称: __littleFsNRead
** 功能描述: cqufsFs nread 操作
** 输　入  : pfdentry         文件控制块
**           piNRead          剩余数据量
** 输　出  : 驱动相关
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsNRead (PLW_FD_ENTRY  pfdentry, INT  *piNRead)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn   = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    
    if (piNRead == LW_NULL) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (pcqufsn == LW_NULL) {
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_FILE_LOCK(pcqufsn) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (S_ISDIR(pcqufsn->CQUFSN_mode)) {
        __CQUFS_FILE_UNLOCK(pcqufsn);
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    *piNRead = (INT)(pcqufsn->CQUFSN_stSize - (size_t)pfdentry->FDENTRY_oftPtr);
    
    __CQUFS_FILE_UNLOCK(pcqufsn);
    
    return  (ERROR_NONE);
}

/*********************************************************************************************************
** 函数名称: __littleFsNRead64
** 功能描述: cqufsFs nread 操作
** 输　入  : pfdentry         文件控制块
**           poftNRead        剩余数据量
** 输　出  : 驱动相关
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsNRead64 (PLW_FD_ENTRY  pfdentry, off_t  *poftNRead)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn   = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    
    if (pcqufsn == LW_NULL) {
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_FILE_LOCK(pcqufsn) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (S_ISDIR(pcqufsn->CQUFSN_mode)) {
        __CQUFS_FILE_UNLOCK(pcqufsn);
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    *poftNRead = (off_t)(pcqufsn->CQUFSN_stSize - (size_t)pfdentry->FDENTRY_oftPtr);
    
    __CQUFS_FILE_UNLOCK(pcqufsn);
    
    return  (ERROR_NONE);
}

/*********************************************************************************************************
** 函数名称: __littleFsSeek
** 功能描述: cqufsFs seek 操作
** 输　入  : pfdentry         文件控制块
**           oftOffset        偏移量
** 输　出  : 驱动相关
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsSeek (PLW_FD_ENTRY  pfdentry,
                         off_t         oftOffset)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn   = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    
    if (pcqufsn == LW_NULL) {
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    if (oftOffset > (size_t)~0) {
        _ErrorHandle(EOVERFLOW);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_FILE_LOCK(pcqufsn) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (S_ISDIR(pcqufsn->CQUFSN_mode)) {
        __CQUFS_FILE_UNLOCK(pcqufsn);
        _ErrorHandle(EISDIR);
        return  (PX_ERROR);
    }
    
    cqufs_file_seek(pcqufsn->CQUFSN_pcqufs, pcqufsn->cqufsfile,oftOffset,CQUFS_SEEK_SET);
    pfdentry->FDENTRY_oftPtr = oftOffset;
    if (pcqufsn->CQUFSN_stVSize < (size_t)oftOffset) {
        pcqufsn->CQUFSN_stVSize = (size_t)oftOffset;
    }
    
    __CQUFS_FILE_UNLOCK(pcqufsn);
    
    return  (ERROR_NONE);
}
/*********************************************************************************************************
** 函数名称: __littleFsWhere
** 功能描述: cqufsFs 获得文件当前读写指针位置 (使用参数作为返回值, 与 FIOWHERE 的要求稍有不同)
** 输　入  : pfdentry            文件控制块
**           poftPos             读写指针位置
** 输　出  : < 0 表示错误
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsWhere (PLW_FD_ENTRY  pfdentry, off_t  *poftPos)
{
    if (poftPos) {
        *poftPos = (off_t)pfdentry->FDENTRY_oftPtr;
        return  (ERROR_NONE);
    }
    
    return  (PX_ERROR);
}
/*********************************************************************************************************
** 函数名称: __littleFsStatGet
** 功能描述: cqufsFs stat 操作
** 输　入  : pfdentry         文件控制块
**           pstat            文件状态
** 输　出  : < 0 表示错误
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsStat (PLW_FD_ENTRY  pfdentry, struct stat *pstat)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn   = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    PCQUFS_VOLUME   pfs  = (PCQUFS_VOLUME)pfdnode->FDNODE_pvFsExtern;
    
    if (!pstat) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_VOL_LOCK(pfs) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    __cqufs_stat(pcqufsn, pfs, pstat);
    
    __CQUFS_VOL_UNLOCK(pfs);
    
    return  (ERROR_NONE);
}

/*********************************************************************************************************
** 函数名称: __littleFsStatfs
** 功能描述: cqufsFs statfs 操作
** 输　入  : pfdentry         文件控制块
**           pstatfs          文件系统状态
** 输　出  : < 0 表示错误
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsStatfs (PLW_FD_ENTRY  pfdentry, struct statfs *pstatfs)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_VOLUME   pfs  = (PCQUFS_VOLUME)pfdnode->FDNODE_pvFsExtern;
    
    if (!pstatfs) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_VOL_LOCK(pfs) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    __cqufs_statfs(pfs, pstatfs);
    
    __CQUFS_VOL_UNLOCK(pfs);
    
    return  (ERROR_NONE);
}


/*********************************************************************************************************
** 函数名称: __littleFsTimeset
** 功能描述: fs 设置文件时间
** 输　入  : pfdentry            文件控制块
**           utim                utimbuf 结构
** 输　出  : < 0 表示错误
** 全局变量: 
** 调用模块: 
*********************************************************************************************************/
static INT  __littleFsTimeset (PLW_FD_ENTRY  pfdentry, struct utimbuf  *utim)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_NODE     pcqufsn   = (PCQUFS_NODE)pfdnode->FDNODE_pvFile;
    PCQUFS_VOLUME   pfs  = (PCQUFS_VOLUME)pfdnode->FDNODE_pvFsExtern;
    
    if (!utim) {
        _ErrorHandle(EINVAL);
        return  (PX_ERROR);
    }
    
    if (__CQUFS_VOL_LOCK(pfs) != ERROR_NONE) {
        _ErrorHandle(ENXIO);
        return  (PX_ERROR);
    }
    
    if (pcqufsn) {
        pcqufsn->CQUFSN_timeAccess = utim->actime;
        pcqufsn->CQUFSN_timeChange = utim->modtime;
    
    } else {
        pfs->CQUFS_time = utim->modtime;
    }
    
    __CQUFS_VOL_UNLOCK(pfs);
    
    return  (ERROR_NONE);
}

/*********************************************************************************************************
** 函数名称: __littleFsIoctl
** 功能描述: cqufsFs ioctl 操作
** 输　入  : pfdentry           文件控制块
**           request,           命令
**           arg                命令参数
** 输　出  : < 0 表示错误
** 全局变量:
** 调用模块:
*********************************************************************************************************/
static INT  __littleFsIoctl (PLW_FD_ENTRY  pfdentry,
                          INT           iRequest,
                          LONG          lArg)
{
    PLW_FD_NODE   pfdnode = (PLW_FD_NODE)pfdentry->FDENTRY_pfdnode;
    PCQUFS_VOLUME   pfs  = (PCQUFS_VOLUME)pfdnode->FDNODE_pvFsExtern;
    off_t         oftTemp;
    INT           iError;
    
    switch (iRequest) {
    
    case FIOCONTIG:
    case FIOTRUNC:
    case FIOLABELSET:
    case FIOATTRIBSET:
        if ((pfdentry->FDENTRY_iFlag & O_ACCMODE) == O_RDONLY) {
            _ErrorHandle(ERROR_IO_WRITE_PROTECTED);
            return  (PX_ERROR);
        }
    }

    switch (iRequest) {

    case FIODISKINIT:                                                   /*  磁盘初始化                  */
        return  (ERROR_NONE);
        
    case FIOSEEK:                                                       /*  文件重定位                  */
        oftTemp = *(off_t *)lArg;
        return  (__littleFsSeek(pfdentry, oftTemp));

    case FIOWHERE:                                                      /*  获得文件当前读写指针        */
        iError = __littleFsWhere(pfdentry, &oftTemp);
        if (iError == PX_ERROR) {
            return  (PX_ERROR);
        } else {
            *(off_t *)lArg = oftTemp;
            return  (ERROR_NONE);
        }
        
    case FIONREAD:                                                      /*  获得文件剩余字节数          */
        return  (__littleFsNRead(pfdentry, (INT *)lArg));
        
    case FIONREAD64:                                                    /*  获得文件剩余字节数          */
        iError = __littleFsNRead64(pfdentry, &oftTemp);
        if (iError == PX_ERROR) {
            return  (PX_ERROR);
        } else {
            *(off_t *)lArg = oftTemp;
            return  (ERROR_NONE);
        }

//    case FIORENAME:                                                     /*  文件重命名                  */
//        return  (__littleFsRename(pfdentry, (PCHAR)lArg));
//
    case FIOLABELGET:                                                   /*  获取卷标                    */
    case FIOLABELSET:                                                   /*  设置卷标                    */
        _ErrorHandle(ENOSYS);
        return  (PX_ERROR);
    
    case FIOFSTATGET:                                                   /*  获得文件状态                */
        return  (__littleFsStat(pfdentry, (struct stat *)lArg));
    
    case FIOFSTATFSGET:                                                 /*  获得文件系统状态            */
        return  (__littleFsStatfs(pfdentry, (struct statfs *)lArg));
    
//    case FIOREADDIR:                                                    /*  获取一个目录信息            */
//        return  (__littleFsReadDir(pfdentry, (DIR *)lArg));
    
    case FIOTIMESET:                                                    /*  设置文件时间                */
        return  (__littleFsTimeset(pfdentry, (struct utimbuf *)lArg));
        
//    case FIOTRUNC:                                                      /*  改变文件大小                */
//        oftTemp = *(off_t *)lArg;
//        return  (__littleFsTruncate(pfdentry, oftTemp));
    
    case FIOSYNC:                                                       /*  将文件缓存回写              */
    case FIOFLUSH:
    case FIODATASYNC:
        return  (ERROR_NONE);
        
//    case FIOCHMOD:
//        return  (__littleFsChmod(pfdentry, (INT)lArg));                    /*  改变文件访问权限            */
    
    case FIOSETFL:                                                      /*  设置新的 flag               */
        if ((INT)lArg & O_NONBLOCK) {
            pfdentry->FDENTRY_iFlag |= O_NONBLOCK;
        } else {
            pfdentry->FDENTRY_iFlag &= ~O_NONBLOCK;
        }
        return  (ERROR_NONE);
//
//    case FIOCHOWN:                                                      /*  修改文件所属关系            */
//        return  (__littleFsChown(pfdentry, (LW_IO_USR *)lArg));
    
    case FIOFSTYPE:                                                     /*  获得文件系统类型            */
        *(PCHAR *)lArg = "littleFS FileSystem";
        return  (ERROR_NONE);
    
    case FIOGETFORCEDEL:                                                /*  强制卸载设备是否被允许      */
        *(BOOL *)lArg = pfs->CQUFS_bForceDelete;
        return  (ERROR_NONE);
        
#if LW_CFG_FS_SELECT_EN > 0
    case FIOSELECT:
        if (((PLW_SEL_WAKEUPNODE)lArg)->SELWUN_seltypType != SELEXCEPT) {
            SEL_WAKE_UP((PLW_SEL_WAKEUPNODE)lArg);                      /*  唤醒节点                    */
        }
        return  (ERROR_NONE);
         
    case FIOUNSELECT:
        if (((PLW_SEL_WAKEUPNODE)lArg)->SELWUN_seltypType != SELEXCEPT) {
            LW_SELWUN_SET_READY((PLW_SEL_WAKEUPNODE)lArg);
        }
        return  (ERROR_NONE);
#endif                                                                  /*  LW_CFG_FS_SELECT_EN > 0     */
        
    default:
        _ErrorHandle(ENOSYS);
        return  (PX_ERROR);
    }
}


/*********************************************************************************************************
                                           API 函数
** 函数名称: API_LittleFsDrvInstall
** 功能描述: 安装 cqufs 文件系统驱动程序
** 输　入  :
** 输　出  : < 0 表示失败
** 全局变量:
** 调用模块:
*********************************************************************************************************/

LW_API INT  API_LittleFsDrvInstall(void)
{
    struct file_operations     fileop;

    if (_G_iLittleFsDrvNum > 0) {
        return  (ERROR_NONE);
    }

    lib_bzero(&fileop, sizeof(struct file_operations));

    fileop.owner = THIS_MODULE;
    fileop.fo_create = __littleFsOpen;
    fileop.fo_release = __littleFsRemove;
    fileop.fo_open = __littleFsOpen;
    fileop.fo_close = __littleFsClose;
    fileop.fo_read = __littleFsRead;
    fileop.fo_read_ex = __littleFsPRead;
    fileop.fo_write = __littleFsWrite;
    fileop.fo_write_ex = __littleFsPWrite;
    fileop.fo_lstat = __littleFsStat;
    fileop.fo_ioctl = __littleFsIoctl;
    // fileop.fo_symlink = __cqufsFsSymlink;
    // fileop.fo_readlink = __cqufsFsReadlink;

    _G_iLittleFsDrvNum = iosDrvInstallEx2(&fileop, LW_DRV_TYPE_NEW_1);     /*  使用 NEW_1 型设备驱动程序   */

    DRIVER_LICENSE(_G_iLittleFsDrvNum, "GPL->Ver 2.0");
    DRIVER_AUTHOR(_G_iLittleFsDrvNum, "CQUFsGroup");
    DRIVER_DESCRIPTION(_G_iLittleFsDrvNum, "norflash fs driver.");

    _DebugHandle(__LOGMESSAGE_LEVEL, "norflash file system installed.\r\n");

    __fsRegister("cqufs", API_LittleFsDevCreate, LW_NULL, LW_NULL);        /*  注册文件系统                */

    return  ((_G_iLittleFsDrvNum > 0) ? (ERROR_NONE) : (PX_ERROR));
}

/*********************************************************************************************************
** 函数名称: API_LittleFsDevCreate
** 功能描述: 创建 cqufs 文件系统设备.
** 输　入  : pcName            设备名(设备挂接的节点地址)
**           pblkd             使用 pblkd->BLKD_pcName 作为 最大大小 标示.
** 输　出  : < 0 表示失败
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
#define NAMESPACE   littleFs
LW_API INT  API_LittleFsDevCreate(PCHAR   pcName, PLW_BLK_DEV  pblkd)
{
    PCQUFS_VOLUME pfs;
    size_t stMax;
    if (_G_iLittleFsDrvNum <= 0) {
        _DebugHandle(__ERRORMESSAGE_LEVEL, "LittleFS: Driver invalidate.\r\n");
        _ErrorHandle(ERROR_IO_NO_DRIVER);
        return  (PX_ERROR);
    }
    if ((pblkd == LW_NULL) || (pblkd->BLKD_pcName == LW_NULL)) {
        _DebugHandle(__ERRORMESSAGE_LEVEL, "LittleFS: block device invalidate.\r\n");
        _ErrorHandle(ERROR_IOS_DEVICE_NOT_FOUND);
        return  (PX_ERROR);
    }
    if ((pcName == LW_NULL) || __STR_IS_ROOT(pcName)) {
        _DebugHandle(__ERRORMESSAGE_LEVEL, "LittleFS: mount name invalidate.\r\n");
        _ErrorHandle(EFAULT);                                           /*  Bad address                 */
        return  (PX_ERROR);
    }
    //new xmy
    // if (sscanf(pblkd->BLKD_pcName, "%zu", &stMax) != 1) {
    //     _DebugHandle(__ERRORMESSAGE_LEVEL, "max size invalidate.\r\n");
    //     _ErrorHandle(EINVAL);
    //     return  (PX_ERROR);
    // }
    //change xmy
    pfs = (PCQUFS_VOLUME)lib_malloc(sizeof(CQUFS_VOLUME));

    if (pfs == LW_NULL) {
        _DebugHandle(__ERRORMESSAGE_LEVEL, "LittleFS: system low memory.\r\n");
        _ErrorHandle(ERROR_SYSTEM_LOW_MEMORY);
        return  (PX_ERROR);
    }
    //change xmy
    lib_bzero(pfs, sizeof(CQUFS_VOLUME));                              /*  清空卷控制块                */
    printf("after lib_zero-----------------------------\n");
    pfs->CQUFS_bValid = LW_TRUE;

    pfs->CQUFS_hVolLock = API_SemaphoreMCreate("LittleFS: cqufs_volume_lock", LW_PRIO_DEF_CEILING,
        LW_OPTION_WAIT_PRIORITY | LW_OPTION_DELETE_SAFE |
        LW_OPTION_INHERIT_PRIORITY | LW_OPTION_OBJECT_GLOBAL,
        LW_NULL);
    printf("2---------------------------------------\n");

    if (!pfs->CQUFS_hVolLock) {   
    //change  xmy                                  /*  无法创建卷锁                */
        _DebugHandle(__ERRORMESSAGE_LEVEL, "can't create the lock.\r\n");
        __SHEAP_FREE(pfs);
        return  (PX_ERROR);
    }

    pfs->CQUFS_mode            = S_IFDIR | DEFAULT_DIR_PERM;
    pfs->CQUFS_uid             = getuid();
    pfs->CQUFS_gid             = getgid();
    pfs->CQUFS_time            = lib_time(LW_NULL);
    pfs->CQUFS_ulCurBlk        = 0ul;
    printf("3---------------------------------------\n");
    //xmy  be useless
//     if (stMax == 0) {
// #if LW_CFG_CPU_WORD_LENGHT == 32
//         pfs->CQUFS_ulMaxBlk = (__ARCH_ULONG_MAX / __RAM_BSIZE);
// #else
//         ps->CQUFS_ulMaxBlk = ((ULONG)(128ul * LW_CFG_GB_SIZE) / __RAM_BSIZE);
// #endif
//     } else {
//         pfs->CQUFS_ulMaxBlk = (ULONG)(stMax / __RAM_BSIZE);
//     }
    //xmy
    // struct cqufs_config* mycfg;
    //littleConfigInitialize(pfs->cqufst->cfg);
    printf("4---------------------------------------\n");
    // cqufs_mount(&(pfs->cqufst),&cfg);
    cqufs_format(&cqufs_test,&cfg);
    printf("test---------------------------------------\n");

    cqufs_mount(&cqufs_test,&cfg);

    printf("5---------------------------------------\n");
    // if (iosDevAddEx(&pfs->CQUFS_devhdrHdr, pcName, _G_iLittleFsDrvNum, DT_DIR)
    //     != ERROR_NONE) {                                                /*  安装文件系统设备            */
    //     printf("iosDevAddEx---------------------------------------\n");
    //     API_SemaphoreMDelete(&pfs->CQUFS_hVolLock);
    //     //xmy
    //     // cqufs_unmount(&(pfs->cqufst));
    //     cqufs_free(pfs);
    //     return  (PX_ERROR);
    // }
    printf("6---------------------------------------\n");
    _DebugFormat(__LOGMESSAGE_LEVEL, "LittleFS: target \"%s\" mount ok.\r\n", pcName);
    printf("7---------------------------------------\n");
    return  (ERROR_NONE);
    


}

/*********************************************************************************************************
** 函数名称: API_LittleFsDevDelete
** 功能描述: 删除一个 cqufs 文件系统设备, 例如: API_LittleFsDevDelete("/mnt/cqufs0");
** 输　入  : pcName            文件系统设备名(物理设备挂接的节点地址)
** 输　出  : < 0 表示失败
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
LW_API INT  API_LittleFsDevDelete(PCHAR   pcName)
{
    if (API_IosDevMatchFull(pcName)) {                                  /*  如果是设备, 这里就卸载设备  */
        return  (unlink(pcName));

    }
    else {
        _ErrorHandle(ENOENT);
        return  (PX_ERROR);
    }
}

#endif
