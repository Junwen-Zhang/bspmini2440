/*********************************************************************************************************
**
**                                    中国软件开源组织
**
**                                   嵌入式实时操作系统
**
**                                     SylixOS(TM)
**
**                               Copyright All Rights Reserved
**
**--------------文件信息--------------------------------------------------------------------------------
**
** 文   件   名: cqufs.h
**
** 创   建   人: cqu Group
**
** 文件创建日期: 2022 年 06 月 04 日
**
** 描        述: cqufs相关工具包的h文件
*********************************************************************************************************/
#ifndef CQUFS_H
#define CQUFS_H

#include <stdint.h>
#include <stdbool.h>
#include "cqufs_util.h"

#ifdef __cplusplus
extern "C"
{
#endif


/*********************************************************************************************************
  版本信息
*********************************************************************************************************/
/*********************************************************************************************************
  说明：
  软件库版本
  主要(top-nibble)，在向后不兼容的更改上增加
  次要(bottom-nibble)，增加特性的增加
*********************************************************************************************************/
#define CQUFS_VERSION 0x00020005
#define CQUFS_VERSION_MAJOR (0xffff & (CQUFS_VERSION >> 16))
#define CQUFS_VERSION_MINOR (0xffff & (CQUFS_VERSION >>  0))
/*********************************************************************************************************
  说明：
  磁盘上数据结构的版本
  主要(top-nibble)，在向后不兼容的更改上增加
  次要(bottom-nibble)，增加特性的增加
*********************************************************************************************************/
#define CQUFS_DISK_VERSION 0x00020000
#define CQUFS_DISK_VERSION_MAJOR (0xffff & (CQUFS_DISK_VERSION >> 16))
#define CQUFS_DISK_VERSION_MINOR (0xffff & (CQUFS_DISK_VERSION >>  0))

/*********************************************************************************************************
  定义信息
*********************************************************************************************************/
/*********************************************************************************************************
  说明：类型dinginess
*********************************************************************************************************/
typedef uint32_t cqufs_size_t;
typedef uint32_t cqufs_off_t;

typedef int32_t  cqufs_ssize_t;
typedef int32_t  cqufs_soff_t;

typedef uint32_t cqufs_block_t;
/*********************************************************************************************************
  说明：类型dinginess
*********************************************************************************************************/
/*********************************************************************************************************
  说明：最大名称大小(以字节为单位)，可以重新定义以减少info结构体的大小。限制为<= 1022。存储在超级块中。
*********************************************************************************************************/
#ifndef CQUFS_NAME_MAX
#define CQUFS_NAME_MAX 255
#endif
/*********************************************************************************************************
  说明：文件的最大大小，以字节为单位，可以重新定义以限制支持其他驱动程序。在磁盘上限制为<= 4294967296(4G)。
  但是，2147483647以上的函数cqufs_file_seek、cqufs_file_size和cqufs_file_tell将返回不正确的值，
  因为使用了有符号整数。存储在超级块中。
*********************************************************************************************************/
#ifndef CQUFS_FILE_MAX
#define CQUFS_FILE_MAX 2147483647
#endif
/*********************************************************************************************************
  说明：自定义属性的最大大小(以字节为单位)可以重新定义，但是使用较小的CQUFS_ATTR_MAX并没有真正的好处。限制为<= 1022。
*********************************************************************************************************/
#ifndef CQUFS_ATTR_MAX
#define CQUFS_ATTR_MAX 1022
#endif

/* 可能的错误码，这些是负数以允许有效的正返回值 */
enum cqufs_error {
    CQUFS_ERR_OK          = 0,    /* 没有错误 */
    CQUFS_ERR_IO          = -5,   /* 发生在设备操作的错误 */
    CQUFS_ERR_CORRUPT     = -84,  /* Corrupted */
    CQUFS_ERR_NOENT       = -2,   /* 缺少目录的entry */
    CQUFS_ERR_EXIST       = -17,  /* Entry已经存在 */
    CQUFS_ERR_NOTDIR      = -20,  /* Entry不是一个目录 */
    CQUFS_ERR_ISDIR       = -21,  /* Entry是一个目录 */
    CQUFS_ERR_NOTEMPTY    = -39,  /* 目录不为空 */
    CQUFS_ERR_BADF        = -9,   /* 坏的文件号 */
    CQUFS_ERR_FBIG        = -27,  /* 文件过大 */
    CQUFS_ERR_INVAL       = -22,  /* 无效参数 */
    CQUFS_ERR_NOSPC       = -28,  /* 设备没有多余的空间 */
    CQUFS_ERR_NOMEM       = -12,  /* 没有多余的存储 */
    CQUFS_ERR_NOATTR      = -61,  /* 没有数据/attr提供 */
    CQUFS_ERR_NAMETOOLONG = -36,  /* 文件名过长 */
};

/*********************************************************************************************************
  说明：文件类型
*********************************************************************************************************/
enum cqufs_type {
    CQUFS_TYPE_REG            = 0x001,/* 文件类型 */
    CQUFS_TYPE_DIR            = 0x002,

    CQUFS_TYPE_SPLICE         = 0x400,/* 内部使用类型*/
    CQUFS_TYPE_NAME           = 0x000,
    CQUFS_TYPE_STRUCT         = 0x200,
    CQUFS_TYPE_USERATTR       = 0x300,
    CQUFS_TYPE_FROM           = 0x100,
    CQUFS_TYPE_TAIL           = 0x600,
    CQUFS_TYPE_GLOBALS        = 0x700,
    CQUFS_TYPE_CRC            = 0x500,

    CQUFS_TYPE_CREATE         = 0x401,/* 内部专门使用类型*/
    CQUFS_TYPE_DELETE         = 0x4ff,
    CQUFS_TYPE_SUPERBLOCK     = 0x0ff,
    CQUFS_TYPE_DIRSTRUCT      = 0x200,
    CQUFS_TYPE_CTZSTRUCT      = 0x202,
    CQUFS_TYPE_INLINESTRUCT   = 0x201,
    CQUFS_TYPE_SOFTTAIL       = 0x600,
    CQUFS_TYPE_HARDTAIL       = 0x601,
    CQUFS_TYPE_MOVESTATE      = 0x7ff,

    // internal chip sources
    CQUFS_FROM_NOOP           = 0x000,/* 内部的chip source*/
    CQUFS_FROM_MOVE           = 0x101,
    CQUFS_FROM_USERATTRS      = 0x102,
};

/*********************************************************************************************************
  说明：文件打开flag
*********************************************************************************************************/
enum cqufs_open_flags {
    CQUFS_O_RDONLY = O_RDONLY,         /* 只读打开文件 */
#ifndef CQUFS_READONLY
    CQUFS_O_WRONLY = O_WRONLY,         /* 只写打开文件 */
    CQUFS_O_RDWR   = O_RDWR,         /* 读与写打开文件 */
    CQUFS_O_CREAT  = O_CREAT,    /* 如果该文件不存在，创建一个文件 */
    CQUFS_O_EXCL   = O_EXCL,    /* 如果文件存在，失败 */
    CQUFS_O_TRUNC  = O_TRUNC,     /* 将现有文件截断为零大小 */
    CQUFS_O_APPEND = O_APPEND,    /* 每次写移动到文件的末尾 */
#endif

/*********************************************************************************************************
  说明：内部使用flag
*********************************************************************************************************/
#ifndef CQUFS_READONLY
    CQUFS_F_DIRTY   = 0x010000, /* 文件与存储不匹配 */
    CQUFS_F_WRITING = 0x020000, /* 自上次flush，文件被写过 */
#endif
    CQUFS_F_READING = 0x040000, /* 自上次flush，文件被读过 */
#ifndef CQUFS_READONLY
    CQUFS_F_ERRED   = 0x080000, /* 写时发生错误 */
#endif
    CQUFS_F_INLINE  = 0x100000, /* 当前目录的entry inline */
};

/*********************************************************************************************************
  说明：文件搜寻 flag
*********************************************************************************************************/
enum cqufs_whence_flags {
    CQUFS_SEEK_SET = 0,   /* 求相对于绝对位置 */
    CQUFS_SEEK_CUR = 1,   /* 求相对于当前文件位置 */
    CQUFS_SEEK_END = 2,   /* 求相对于当前文件结尾位置 */
};

/*********************************************************************************************************
  说明：在cqufs初始化期间提供的配置
*********************************************************************************************************/
struct cqufs_config {
    /* 不透明的用户提供的上下文可用于向块设备操作传递信息 */
    void *context;

    /* 读取块中的一个区域。负的错误码被传播给用户。 */
    int (*read)(const struct cqufs_config *c, cqufs_block_t block,
            cqufs_off_t off, void *buffer, cqufs_size_t size);

    /* 对一个块中的一个区域进行编程。该块之前必须被擦除。负的错误码被传播给用户。如果块被认为是坏的，可能返回CQUFS_ERR_CORRUPT。 */
    int (*prog)(const struct cqufs_config *c, cqufs_block_t block,
            cqufs_off_t off, const void *buffer, cqufs_size_t size);

    /* 抹去一块。在编写程序之前，必须先将一个块擦除。擦除块的状态未定义。负的错误码被传播给用户。如果块被认为是坏的，可能返回CQUFS_ERR_CORRUPT。 */
    int (*erase)(const struct cqufs_config *c, cqufs_block_t block);

    /* 同步底层块设备的状态。负的错误码被传播给用户。 */
    int (*sync)(const struct cqufs_config *c);

#ifdef CQUFS_THREADSAFE
    /* 锁定底层块设备。负的错误码被传播给用户。 */
    int (*lock)(const struct cqufs_config *c);

    /* 解锁底层块设备。负的错误码被传播给用户。 */
    int (*unlock)(const struct cqufs_config *c);
#endif

    /* 以字节为单位读取的块的最小大小。所有读操作都是该值的倍数。 */
    cqufs_size_t read_size;

    /* 以字节为单位的块程序的最小大小。所有程序操作都是该值的倍数。 */
    cqufs_size_t prog_size;

    /* 可擦块的大小(以字节为单位)。这不会影响ram的消耗，而且可能会大于物理擦除的大小。然而，非内联文件至少占用一个块。必须是读取大小和程序大小的倍数。 */
    cqufs_size_t block_size;

    /* 设备上可擦除块的数量。 */
    cqufs_size_t block_count;

    /* 在cqufs删除元数据日志并将元数据移动到另一个块之前的擦除周期数。建议数值在100 ~ 1000之间，数值越大，磨损分布越不一致，性能越好。设置为-1将禁用块级损耗均衡。 */
    int32_t block_cycles;

    /* 以字节为单位的块缓存的大小。每个缓存在RAM中缓冲一个块的一部分。cqufs需要一个读缓存，一个程序缓存，以及每个文件一个额外的缓存。较大的缓存可以存储更多的数据并减少磁盘访问次数，从而提高性能。必须是读取和程序大小的倍数，以及块大小的一个因子。 */
    cqufs_size_t cache_size;

    /* 以字节为单位的前向缓冲区的大小。更大的前向缓冲区会增加分配过程中发现的块的数量。前瞻缓冲区存储为一个紧凑的位图，因此RAM的每个字节可以跟踪8个块。必须是8的倍数。 */
    cqufs_size_t lookahead_size;

    /* 可选静态分配读缓冲区。必须cache_size。默认情况下，使用cqufs_malloc来分配这个缓冲区。 */
    void *read_buffer;

    /* 可选静态分配程序缓冲区。必须cache_size。默认情况下，使用cqufs_malloc来分配这个缓冲区。 */
    void *prog_buffer;

    /* 可选静态分配的前向缓冲区。必须是lookahead_size并对齐到32位边界。默认情况下，使用cqufs_malloc来分配这个缓冲区。 */
    void *lookahead_buffer;

    /* 可选的文件名长度上限(以字节为单位)。除了info结构的大小由CQUFS_NAME_MAX定义控制之外，更大的名称没有缺点。0时默认为CQUFS_NAME_MAX。存储在超级块中，必须被其他的cqufs驱动尊重。 */
    cqufs_size_t name_max;

    /* 可选的文件字节数上限。对于较大的文件没有缺点，但必须<= CQUFS_FILE_MAX。0时默认为CQUFS_FILE_MAX。存储在超级块中。 */
    cqufs_size_t file_max;

    /* 自定义属性(以字节为单位)的可选上限。更大的属性没有缺点，但必须<= CQUFS_ATTR_MAX。0时默认为CQUFS_ATTR_MAX。 */
    cqufs_size_t attr_max;

    /* 给元数据对的总空间(以字节为单位)的可选上限。在具有较大块(例如128kB)的设备上，将其设置为较低的大小(2-8kB)有助于限制元数据压缩时间。必须是<= block_size。0时默认为block_size。 */
    cqufs_size_t metadata_max;
};
/*********************************************************************************************************
  说明：文件信息结构
*********************************************************************************************************/
struct cqufs_info {
    /* 文件类型，CQUFS_TYPE_REG或CQUFS_TYPE_DIR */
    uint8_t type;

    /* 文件的大小，仅对REG文件有效。限制为32位。 */
    cqufs_size_t size;

    /* 存储为以空结尾的字符串的文件名称。限制为CQUFS_NAME_MAX+1，可以通过重新定义CQUFS_NAME_MAX来减少RAM。CQUFS_NAME_MAX存储在超级块中，必须被其他的cqufs驱动遵守。 */
    char name[CQUFS_NAME_MAX+1];
};
/*********************************************************************************************************
  说明：自定义属性结构，用于描述在文件写入期间以原子方式提交的自定义属性。
*********************************************************************************************************/
struct cqufs_attr {
    /* 8位类型的属性，由用户提供，用于识别属性 */
    uint8_t type;

    /* 指向包含属性的缓冲区的指针 */
    void *buffer;

    /* 属性大小(以字节为单位)，限制为CQUFS_ATTR_MAX */
    cqufs_size_t size;
};
/*********************************************************************************************************
  说明：cqufs_file_opencfg期间提供的可选配置
*********************************************************************************************************/
struct cqufs_file_config {
    /* 可选静态分配的文件缓冲区。必须cache_size。默认情况下，使用cqufs_malloc来分配这个缓冲区。 */
    void *buffer;

    /* 与文件相关的可选自定义属性列表。如果文件是用读访问打开的，那么在打开调用期间将从磁盘读取这些属性。如果文件是用写访问打开的，那么在文件同步或关闭时，这些属性将被写入磁盘。这个写操作随着文件内容的更新而自动发生。 */
    /* 自定义属性由8位类型唯一标识，并限制为CQUFS_ATTR_MAX字节。读取时，如果存储的属性小于缓冲区，则将用零填充。如果存储的属性较大，则会自动截断。如果未找到该属性，将隐式创建该属性。*/
    struct cqufs_attr *attrs;

    /* 列表中的自定义属性数 */
    cqufs_size_t attr_count;
};

/*********************************************************************************************************
  说明：内部cqufs数据结构
*********************************************************************************************************/
typedef struct cqufs_cache {
    cqufs_block_t block;
    cqufs_off_t off;
    cqufs_size_t size;
    uint8_t *buffer;
} cqufs_cache_t;

typedef struct cqufs_mdir {
    cqufs_block_t pair[2];
    uint32_t rev;
    cqufs_off_t off;
    uint32_t etag;
    uint16_t count;
    bool erased;
    bool split;
    cqufs_block_t tail[2];
} cqufs_mdir_t;
/*********************************************************************************************************
  说明：cqufs目录类型
*********************************************************************************************************/
typedef struct cqufs_dir {
    struct cqufs_dir *next;
    uint16_t id;
    uint8_t type;
    cqufs_mdir_t m;

    cqufs_off_t pos;
    cqufs_block_t head[2];
} cqufs_dir_t;
typedef cqufs_dir_t* PCQUFS_DIR;
/*********************************************************************************************************
  说明：cqufs文件类型
*********************************************************************************************************/
typedef struct cqufs_file {
    struct cqufs_file *next;
    uint16_t id;
    uint8_t type;
    cqufs_mdir_t m;

    struct cqufs_ctz {
        cqufs_block_t head;
        cqufs_size_t size;
    } ctz;

    uint32_t flags;
    cqufs_off_t pos;
    cqufs_block_t block;
    cqufs_off_t off;
    cqufs_cache_t cache;

    const struct cqufs_file_config *cfg;
} cqufs_file_t;
typedef cqufs_file_t* PCQUFS_FILE;

typedef struct cqufs_superblock {
    uint32_t version;
    cqufs_size_t block_size;
    cqufs_size_t block_count;
    cqufs_size_t name_max;
    cqufs_size_t file_max;
    cqufs_size_t attr_max;
} cqufs_superblock_t;

typedef struct cqufs_gstate {
    uint32_t tag;
    cqufs_block_t pair[2];
} cqufs_gstate_t;
/*********************************************************************************************************
  说明：cqufs文件系统类型
*********************************************************************************************************/
typedef struct cqufs {
    cqufs_cache_t rcache;
    cqufs_cache_t pcache;

    cqufs_block_t root[2];
    struct cqufs_mlist {
        struct cqufs_mlist *next;
        uint16_t id;
        uint8_t type;
        cqufs_mdir_t m;
    } *mlist;
    uint32_t seed;

    cqufs_gstate_t gstate;
    cqufs_gstate_t gdisk;
    cqufs_gstate_t gdelta;

    struct cqufs_free {
        cqufs_block_t off;
        cqufs_block_t size;
        cqufs_block_t i;
        cqufs_block_t ack;
        uint32_t *buffer;
    } free;

    const struct cqufs_config *cfg; //there have!!!!!!!!!!!!!!!!!!!!!xmy
    cqufs_size_t name_max;
    cqufs_size_t file_max;
    cqufs_size_t attr_max;

#ifdef CQUFS_MIGRATE
    struct cqufs1 *cqufs1;
#endif
} cqufs_t;
typedef cqufs_t* PCQUFS;


/*********************************************************************************************************
  说明：文件系统函数
*********************************************************************************************************/

#ifndef CQUFS_READONLY
/*********************************************************************************************************
  说明：用cqufs格式化块设备
*********************************************************************************************************/
/* 需要cqufs对象和配置结构。这会重击cqufs对象，并且不会使文件系统保持挂载状态。配置结构必须为零，以实现默认值和向后兼容性。失败时返回负错误代码。 */
int cqufs_format(cqufs_t *cqufs, const struct cqufs_config *config);
#endif

/*********************************************************************************************************
  说明：挂载cqufs
*********************************************************************************************************/
/* 需要cqufs对象和配置结构。可以使用多个cqufs对象同时装载多个文件系统。装载时必须同时分配cqufs和config。配置结构必须为零，以实现默认值和向后兼容性。失败时返回负错误代码。 */
int cqufs_mount(cqufs_t *cqufs, const struct cqufs_config *config);

/*********************************************************************************************************
  说明：卸载cqufs
*********************************************************************************************************/
/* 除了释放任何分配的资源外，什么都不做。失败时返回负错误代码。 */
int cqufs_unmount(cqufs_t *cqufs);
/*********************************************************************************************************
  说明：总的操作
*********************************************************************************************************/

#ifndef CQUFS_READONLY
/*********************************************************************************************************
  说明：删除文件或目录
*********************************************************************************************************/
/* 如果删除目录，目录必须为空。失败时返回负错误代码。 */
int cqufs_remove(cqufs_t *cqufs, const char *path);
#endif

#ifndef CQUFS_READONLY
/*********************************************************************************************************
  说明：删除或重命名文件或目录
*********************************************************************************************************/
/* 如果目标存在，则其类型必须与源匹配。如果目标是目录，则目录必须为空。失败时返回负错误代码。 */
int cqufs_rename(cqufs_t *cqufs, const char *oldpath, const char *newpath);
#endif
/*********************************************************************************************************
  说明：查找文件或目录
*********************************************************************************************************/
/* 根据指定的文件或目录填写信息结构。失败时返回负错误代码。 */
int cqufs_stat(cqufs_t *cqufs, const char *path, struct cqufs_info *info);
/*********************************************************************************************************
  说明：获取自定义属性
*********************************************************************************************************/
/* 自定义属性由8位类型唯一标识，并限制为CQUFS_ATTR_MAX字节。读取时，如果存储的属性小于缓冲区，则将用零填充。如果存储的属性较大，则会自动截断。如果未找到属性，则返回错误CQUFS_ERR_NOATTR，并用零填充缓冲区。 */
/* 返回属性的大小，或失败时返回负错误代码。注意，返回的大小是磁盘上属性的大小，与缓冲区的大小无关。这可用于动态分配缓冲区或检查是否存在。 */
cqufs_ssize_t cqufs_getattr(cqufs_t *cqufs, const char *path,
        uint8_t type, void *buffer, cqufs_size_t size);

#ifndef CQUFS_READONLY
/*********************************************************************************************************
  说明：设置自定义属性
*********************************************************************************************************/
/* 自定义属性由8位类型唯一标识，并限制为CQUFS_ATTR_MAX字节。如果未找到属性，则将隐式创建该属性。失败时返回负错误代码。 */
int cqufs_setattr(cqufs_t *cqufs, const char *path,
        uint8_t type, const void *buffer, cqufs_size_t size);
#endif

#ifndef CQUFS_READONLY
/*********************************************************************************************************
  说明：删除自定义属性
*********************************************************************************************************/
/* 如果未找到属性，则不会发生任何事情。失败时返回负错误代码。 */
int cqufs_removeattr(cqufs_t *cqufs, const char *path, uint8_t type);
#endif


/*********************************************************************************************************
  说明：文件操作
*********************************************************************************************************/

#ifndef CQUFS_NO_MALLOC
/*********************************************************************************************************
  说明：打开文件
*********************************************************************************************************/
/* 打开文件的模式由标志决定，这些标志是枚举cqufs_open_flag中的值，它们按位或在一起。失败时返回负错误代码。 */
int cqufs_file_open(cqufs_t *cqufs, cqufs_file_t *file,
        const char *path, int flags);

/* 如果定义了CQUFS_NO_MALLOC，CQUFS_file_open()将因CQUFS_ERR_noem而失败，因此将CQUFS_file_opencfg()与config一起使用。缓冲区集。 */
#endif
/*********************************************************************************************************
  说明：打开具有额外配置的文件
*********************************************************************************************************/
/* 打开文件的模式由标志决定，这些标志是枚举cqufs_open_flag中的值，它们按位或在一起。如上所述，config结构为每个文件提供了额外的配置选项。必须在文件打开时分配配置结构，并且必须将配置结构归零以获得默认值和向后兼容性。失败时返回负错误代码。 */
int cqufs_file_opencfg(cqufs_t *cqufs, cqufs_file_t *file,
        const char *path, int flags,
        const struct cqufs_file_config *config);

/*********************************************************************************************************
  说明：关闭文件
*********************************************************************************************************/
/* 任何挂起的写入都会写入存储，就像调用了同步一样，并释放任何分配的资源。失败时返回负错误代码。 */
int cqufs_file_close(cqufs_t *cqufs, cqufs_file_t *file);
/*********************************************************************************************************
  说明：同步存储上的文件
*********************************************************************************************************/
/* 任何挂起的写入都会写入存储。失败时返回负错误代码。 */
int cqufs_file_sync(cqufs_t *cqufs, cqufs_file_t *file);
/*********************************************************************************************************
  说明：从文件中读取数据
*********************************************************************************************************/
/* 获取一个缓冲区和大小，指示读取数据的存储位置。返回读取的字节数，或失败时返回负错误代码。 */
cqufs_ssize_t cqufs_file_read(cqufs_t *cqufs, cqufs_file_t *file,
        void *buffer, cqufs_size_t size);

#ifndef CQUFS_READONLY
/*********************************************************************************************************
  说明：从文件中写入数据
*********************************************************************************************************/
/* 获取指示要写入的数据的缓冲区和大小。在调用sync或close之前，不会在存储上实际更新文件。返回写入的字节数，或失败时返回负错误代码。 */
cqufs_ssize_t cqufs_file_write(cqufs_t *cqufs, cqufs_file_t *file,
        const void *buffer, cqufs_size_t size);
#endif
/*********************************************************************************************************
  说明：改变文件位置
*********************************************************************************************************/
/* 位置变化由偏移和位置标志确定。返回文件的新位置，或失败时返回负错误代码。 */
cqufs_soff_t cqufs_file_seek(cqufs_t *cqufs, cqufs_file_t *file,
        cqufs_soff_t off, int whence);

#ifndef CQUFS_READONLY
/*********************************************************************************************************
  说明：将文件大小截断为指定大小
*********************************************************************************************************/
/* 失败时返回负错误代码。*/
int cqufs_file_truncate(cqufs_t *cqufs, cqufs_file_t *file, cqufs_off_t size);
#endif
/*********************************************************************************************************
** 函数名称: cqufs_file_tell
** 功能描述: 返回文件位置
** 输　入  :
** 输　出  : 返回文件的位置，失败时返回负的错误码
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
cqufs_soff_t cqufs_file_tell(cqufs_t *cqufs, cqufs_file_t *file);
/*********************************************************************************************************
** 函数名称: cqufs_file_rewind
** 功能描述: 将文件当前的位置更改为文件的开头
** 输　入  :
** 输　出  : 等价于cqufs_file_seek(cqufs, file, 0, CQUFS_SEEK_SET)失败返回负的错误码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_file_rewind(cqufs_t *cqufs, cqufs_file_t *file);
/*********************************************************************************************************
** 函数名称: cqufs_file_size
** 功能描述: 返回文件大小
** 输　入  :
** 输　出  : 类似于cqufs_file_seek(cqufs, file, 0, CQUFS_SEEK_END)返回文件大小，失败时返回负的错误码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
cqufs_soff_t cqufs_file_size(cqufs_t *cqufs, cqufs_file_t *file);

/*********************************************************************************************************
  说明：目录操作
*********************************************************************************************************/

#ifndef CQUFS_READONLY
/*********************************************************************************************************
** 函数名称: cqufs_mkdir
** 功能描述: 创建目录
** 输　入  :
** 输　出  : 失败时返回负的错误码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_mkdir(cqufs_t *cqufs, const char *path);
#endif
/*********************************************************************************************************
** 函数名称: cqufs_dir_open
** 功能描述: 打开目录，一旦打开一个目录，就可以用read来遍历文件。
** 输　入  :
** 输　出  : 失败时返回负的错误码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_dir_open(cqufs_t *cqufs, cqufs_dir_t *dir, const char *path);
/*********************************************************************************************************
** 函数名称: cqufs_dir_close
** 功能描述: 关闭目录，释放任何已分配的资源。
** 输　入  :
** 输　出  : 失败时返回负的错误码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_dir_close(cqufs_t *cqufs, cqufs_dir_t *dir);
/*********************************************************************************************************
** 函数名称: cqufs_dir_read
** 功能描述: 读目录里的一个条目
** 输　入  : 根据指定的文件或目录填写信息结构。
** 输　出  : 成功时返回一个正值，在目录末尾返回0，失败时返回一个负值错误码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_dir_read(cqufs_t *cqufs, cqufs_dir_t *dir, struct cqufs_info *info);
/*********************************************************************************************************
** 函数名称: cqufs_dir_seek
** 功能描述: 改变目录的位置
** 输　入  : 新的off必须是前面从tell返回的值，并指定目录查找中的绝对偏移量。
** 输　出  : 失败时返回一个负值错误码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_dir_seek(cqufs_t *cqufs, cqufs_dir_t *dir, cqufs_off_t off);
/*********************************************************************************************************
** 函数名称: cqufs_dir_tell
** 功能描述: 返回目录的位置
** 输　入  : 
** 输　出  : 返回目录的位置，失败时返回负的错误代码。返回的偏移量只用于查找，可能没有意义，但确实指示了目录迭代中的当前位置。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
cqufs_soff_t cqufs_dir_tell(cqufs_t *cqufs, cqufs_dir_t *dir);
/*********************************************************************************************************
** 函数名称: cqufs_dir_rewind
** 功能描述: 将目录的位置更改为目录的开头
** 输　入  : 
** 输　出  : 失败时返回负的错误代码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_dir_rewind(cqufs_t *cqufs, cqufs_dir_t *dir);

/*********************************************************************************************************
  说明：文件系统级别的文件系统操作
*********************************************************************************************************/
/*********************************************************************************************************
** 函数名称: cqufs_fs_size
** 功能描述: 找到文件系统的当前大小
** 输　入  : 
** 输　出  : 返回已分配的块的数量，失败时返回负值的错误码。如果文件共享COW结构，返回的大小可能比文件系统实际的大小大。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
cqufs_ssize_t cqufs_fs_size(cqufs_t *cqufs);
/*********************************************************************************************************
** 函数名称: cqufs_fs_traverse
** 功能描述: 遍历文件系统正在使用的所有块，所提供的回调将被文件系统当前使用的每个块地址调用。这可以用来确定哪些块正在使用，或者有多少存储可用。
** 输　入  : 
** 输　出  : 失败时返回负的错误代码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/
int cqufs_fs_traverse(cqufs_t *cqufs, int (*cb)(void*, cqufs_block_t), void *data);

#ifndef CQUFS_READONLY
#ifdef CQUFS_MIGRATE
/*********************************************************************************************************
** 函数名称: cqufs_migrate
** 功能描述: 尝试迁移之前版本的cqufs，行为类似于cqufs_format函数。尝试挂载以前版本的cqufs和更新文件系统，以便它可以挂载与当前版本的cqufs。
** 输　入  : 需要一个cqufs对象和配置结构。这将破坏cqufs对象，并且不会挂载文件系统。配置结构必须为默认值零和向后兼容。
** 输　出  : 失败时返回负的错误代码。
** 全局变量:
** 调用模块:
                                           API 函数
*********************************************************************************************************/

int cqufs_migrate(cqufs_t *cqufs, const struct cqufs_config *cfg);
#endif
#endif


#ifdef __cplusplus
} /* 外部 "C" */
#endif

#endif
